select * from emp;
-----------------------------------RANK----------------------------------------------------------------------
select empno, ename, sal,
                rank() Over(order by sal desc) 급여순위
from emp; 
-- 따로 묶어서 계산할 것이 없으니까 PARTITION BY 가 없다.
-- 출력 순서는 [ rank() Over(order by sal desc) 급여순위 ] 를 기준으로 나타난다.
-------------------------------------------------------------------------------------------------------------   
SELECT RANK(1700) WITHIN GROUP (ORDER BY SAL DESC) AS 순위
FROM EMP;
-- GROUP (ORDER BY SAL DESC) 로 만들어진 그룹내에서 RANK(1700)의 순위를 출력해라
-- EMP table에는 RANK라는 column이 없으므로 위와 같이 특정 기준을 정해줘야한다.

SELECT RANK(1700) AS 순위 FROM EMP; --안 된다. 순위를 매기기 위한 기준이 있어야한다.
-------------------------------------------------------------------------------------------------------------
select empno, ename, sal,
                dense_rank() Over(order by sal desc) 급여순위
from emp;
-------------------------------------------------------------------------------------------------------------
select * from emp;

-- 5p, 급여 전체에 순위를 매김
select ename, deptno, sal,
    rank() over (order by sal desc) "순위1",
    DENSE_RANK() over (order by sal desc) "순위2",
    DENSE_RANK() over (partition by deptno order by sal desc) "순위3" -- 그룹 안에서의 순위
    -- 덩어리를 나눠서 봐야한다.
    -- partition by deptno : deptno별로 소그룹으로 묶는다. (첫번째 덩어리)
    -- order by sal desc : 묶은 소그룹 내에서 sal을 기준으로 순위를 매긴다. (두번째 덩어리)
from emp
order by 2 desc; --컬럼 인덱스 값(EMP TABLE의 2번째 컬럼을 의미)
-------------------------------------------------------------------------------------------------------------
--rank 를 이용한 top N 분석 방법
select * from (select ename, sal, rank() over (order by sal desc) 순위 from emp)
where 순위 <= 5;
-------------------------------------------------------------------------------------------------------------
--급여 적은순(내림차순) 11 순위에 해당하는 정보 조회
select * from (select ename, sal, dense_rank() over (order by sal desc) 순위 from emp)
where 순위 = 11;
-----------------------------------CUME_DIST()----------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
SELECT ename, sal,
ROUND(CUME_DIST() OVER (ORDER BY sal), 1) 누적분산 --sal을 기준으로 누적분산을 구해라
FROM emp
WHERE DEPTNO = 30; -- cf) WHERE DEPTNO = '30'; --> 이렇게해도 동일하게 인식
-- 전체의 합을 구한 후 그 합에서 950이 얼마의 비율을 차지하고 있는냐
----------------------------------------NTILE()---------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
SELECT ename, sal,
NTILE(4) OVER(ORDER BY sal) 등급
FROM emp;
-- sal을 (ORDER BY sal) 기준으로 정렬한 후 순위를 매겨라
-- 이때 순위를 4덩어리로 나누어라
----------------------------------------ROW_NUMBER()----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
SELECT empno, ename, sal, hiredate,
ROW_NUMBER() OVER (ORDER BY sal DESC, hiredate ASC) 순번
FROM emp;
-- 2개(sal DESC, hiredate ASC)를 기준으로 정렬(ORDER BY)한 다음에 그것에 순번을 매긴다.
-- (sal DESC)를 기준으로 먼저 정렬한 후, 그 결과값을 가지고 또 (hiredate ASC) 기준으로 정렬한다.
-- rownum대신 이것을 써도 된다.(서브쿼리를 하나 덜 써도 된다.)
----------------------------------------집계함수1--------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
-- rows : 부분그룹인 윈도우의 크기를 물리적으로 지정
-- unbounded preceding : 윈도우의 첫행 / unbounded following : 윈도우의 마지막행
-- CURRENT ROW : 현재 행 (내가 위치해 있는 행을 의미)
-- PARTITION BY deptno ORDER BY empno
-- 1. PARTITION BY deptno : 부서번호별로 소그룹을 만들어라
-- 2. ORDER BY empno : 소그룹별로 empno의 오름차순으로 정렬해라
SELECT EMPno, sal,
    SUM(sal) OVER (PARTITION BY deptno ORDER BY empno
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) "win1",
        -- 윈도우의 첫 행 ~ 마지막 행까지의 sal 합계
    SUM(sal) OVER (PARTITION BY deptno ORDER BY empno
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) "win2",
        -- 윈도우의 첫 행 ~ 내가 있는 행까지의 sal 합계
    SUM(sal) OVER (PARTITION BY deptno ORDER BY empno
         ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) "win3"
         -- 윈도우의 내가 있는 행 ~ 윈도우의 마지막 행까지의 sal 합계
FROM EMP
WHERE deptno = '20';
----------------------------------------집계함수2--------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
-- 1 preceding and 1 following : 현재 행을 중심으로 이전행과 다음행의 급여합계
-- 1 preceding and current row : 이전 행과 현재 행의 급여 합계
-- current row and 1 following : 현재 행과 다음행의 합계
SELECT EMPno, sal,
    SUM(sal) OVER (PARTITION BY deptno ORDER BY empno ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) "win1",
    SUM(sal) OVER (PARTITION BY deptno ORDER BY empno ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) "win2",
    SUM(sal) OVER (PARTITION BY deptno ORDER BY empno ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING) "win3"
FROM EMP
WHERE deptno = 20;
----------------------------------------RATIO_TO_REPORT-------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
SELECT ename, sal,
    LPAD(TRUNC(RATIO_TO_REPORT(sal) OVER() * 100, 0), 5) || ' %' 비율,
    TO_CHAR(TRUNC(RATIO_TO_REPORT(sal) OVER() * 20000000, 0), 'L00,999,999') "추가로 받게될 급여"
FROM EMP;
-- RATIO_TO_REPORT(sal) : 전체 sal에서 각 직원이 차지하는 sal 비율을 구하는것
-- 그리고 그 결과에다가 * 100 / * 20000000을 곱한다.
-- ex) RATIO_TO_REPORT(sal) OVER() * 100 --> 전체를 100으로 봤을때 각 직원의 급여가 몇 프로를 차지하느냐
-- OVER()으로 비어있으므로 출력 기준은 따로 없다.

SELECT ename, sal, deptno,
    LPAD(TRUNC(RATIO_TO_REPORT(sal) OVER(partition by deptno) * 100, 0), 5) || ' %' 비율,
    -- 부서별로 묶었을 때(부서별로 소그룹을 만들었을 때) 각 부서에서 얼마를 차지하는가
    TO_CHAR(TRUNC(RATIO_TO_REPORT(sal) OVER() * 20000000, 0), 'L99,999,999') "추가로 받게될 급여"
FROM EMP;
-----------------------------Lag(조회할 범위, 이전위치, 기준 현재위치) 이전거를 찾는거------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
-- LAG(sal, 1, 0) --> 1 : 위의 행값 , 0 : 이전행이 없으면 0 처리
-- LAG(sal, 1, sal) --> -- 이전행이 없으면 현재 행의 값을 출력
SELECT ename, deptno, sal, 
    LAG(sal, 1, 0) OVER (ORDER BY sal) 이전값, -- (ORDER BY sal) 먼저 sal을 오름차순으로 정렬한 다음에
    LAG(sal, 1, sal) OVER (ORDER BY sal) " 조회 2", -- (ORDER BY sal) 먼저 sal을 오름차순으로 정렬한 다음에
    LAG(sal, 1, sal) OVER (PARTITION BY deptno ORDER BY sal) "조회 3"
    -- PARTITION BY deptno ORDER BY sal : deptno별로 묶음 다음에 sal 오름차순으로 정렬
    -- 부서 그룹안에서의 이전 행값 출력
FROM EMP;
--------------------------------------------------------------------------------------------------------
SELECT ename, deptno, sal,
    LAG(sal, 1, sal) OVER (PARTITION BY deptno ORDER BY sal) "조회 3"
FROM EMP;
--------------------------Lead(조회할 범위, 다음행수, 0 또는 컬럼명) 다음거를 찾는거--------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
SELECT ename, deptno, sal,
    LEAD(sal, 1, 0) OVER (ORDER BY sal) 다음값, -- 1 : 다음 행값 , 0 : 다음행이 없으면 0 처리함
    LEAD(sal, 1, sal) OVER (ORDER BY sal) " 조회 2", -- 다음행이 없으면 현재 행의 값을 출력
    LEAD(sal, 1, sal) OVER (PARTITION BY deptno ORDER BY sal) " 조회 3"
    -- 부서 그룹안에서의 다음 행값 출력
FROM EMP;
--------------------------------------------------------------------------------------------------------
SELECT ename, deptno, sal,
    LEAD(sal, 1, sal) OVER (PARTITION BY deptno ORDER BY sal) " 조회 3"
FROM EMP;
----------------------------------------FIRST_VALUE----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
-- rows : 부분그룹인 윈도우의 크기를 물리적으로 지정
-- unbounded preceding : 윈도우의 첫행 / unbounded following : 윈도우의 마지막행
-- CURRENT ROW : 현재 행 (내가 위치해 있는 행을 의미)
SELECT DEPTNO, ENAME, SAL,
                            FIRST_VALUE(ENAME) OVER 
                            (PARTITION BY DEPTNO -- DEPTNO별로 묶은 다음에
                            ORDER BY SAL DESC, ename -- SAL DESC 순으로 정렬
                            -- 동일 SAL 처리를 위해 ename 기준 추가
                            ROWS UNBOUNDED PRECEDING) as DEPT_RICH
                            -- 소그룹별로 첫번째 행에 있는거 출력
FROM EMP;
----------------------------------------LAST_VALUE-----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
-- rows : 부분그룹인 윈도우의 크기를 물리적으로 지정
-- unbounded preceding : 윈도우의 첫행 / unbounded following : 윈도우의 마지막행
-- CURRENT ROW : 현재 행 (내가 위치해 있는 행을 의미)
SELECT DEPTNO, ENAME, SAL,
                          LAST_VALUE(ENAME) OVER
                         (PARTITION BY DEPTNO -- DEPTNO 별로 묶은 다음에
                          ORDER BY SAL DESC-- SAL DESC 순으로 정렬
                          ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) as DEPT_POOR
                          -- 소그룹별로 현재 행(내꺼)부터 ~ 마지막 행 중에서 마지막 행을 찾아라
                          -- (내가 끝에있으면 그냥 내가 나온다.)
FROM EMP;
------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
----------------------------------------ROLLUP-----------------------------------------------------------------
select deptno, job, sum(sal)
from emp
group by rollup(deptno, job);
-- deptno를 기준으로 정렬을 한후 job을 기준으로 롤업
-- deptno를 기준으로 먼저 그룹을 묶은 후 그 다음에 job으로 또 다시 세부적으로 묶는다.
--------------------------------------------------------------------------------------------------------------------
select job, deptno, sum(sal)
from emp
group by rollup(job, deptno);
-- job을 기준으로 정렬을 한후 deptno를 기준으로 롤업
-- job을 기준으로 먼저 그룹을 묶은 후(대분류) 그 안에서 또 다시 deptno 별로 묶는다.(소분류)
--------------------------------------------------------------------------------------------------------------------
-- 마지막 총액만 보고 싶을때
select deptno, job, sum(sal)
from emp
group by rollup((job, deptno))
order by deptno;
------------------------------------------------------------------------------------------
select deptno, job, sum(sal)
from emp
group by deptno, rollup(job);
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
------------------------------------------------?CUBE----------------------------------------------------------------
select deptno, job, sum(sal)
from emp
group by cube(deptno, job);
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
------------------------------------------------?GROUPING SETS-------------------------------------------------------
select deptno, job, sum(sal)
from emp
group by grouping sets (deptno, job);
-- deptno 별로 묶은 결과와 job 별로 묶은결과를 따로 보여준다.
--------------------------------------------------------------------------------------------------------------------
select deptno, job, sum(sal)
from emp
group by grouping sets ((deptno, job), ());
-- deptno & job으로 함께 묶은 결과를 보여준다.
--------------------------------------------------------------------------------------------------------------------
select deptno, job, sum(sal)
from emp
group by grouping sets ((deptno, job), deptno);
-- (deptno, job)로 묶은 다음에 deptno로 다시 한번 묶은 결과를 출력
-- 뒤의 조건은 또 추가할 수 있다.
--------------------------------------------------------------------------------------------------------------------
select deptno, job, sum(sal)
from emp
group by grouping sets ((deptno, job), job);
-- (deptno, job)로 묶은 다음에 job으로 다시 한번 묶은 결과를 출력
-- 뒤의 조건은 또 추가할 수 있다.