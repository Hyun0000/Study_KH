<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
    // ==========================================================array==========================================================
    // ========================================================================================================================
    // 리터럴 방식
    var arr1 = ['apple', 'banana', 'cherry'];
    console.log(arr1.length);

    // Array 객체 생성 방식
    var arr2 = new Array('orange', 'grape', 'kiwi');
    for (let i = 0; i < arr2.length; i++) {
        console.log(arr2[i]);
    }

    // 배열을 문자열로 만들기 – join() --> var str = 배열.join([separator]);
    // separator : 배열 요소를 구분하기 위한 문자열. 구분자로 이용되며 필수 사항은 아니다
    var arr1 = ['apple', 'banana', 'cherry'];
    var arr1Str = arr1.join();
    console.log(arr1Str);
    console.log(arr1Str.charAt(5));

    // 문자열을 배열로 만들기 – split()
    // var arr = 문자열.split(separator); --> separator : 구분자
    // 문자열에서 ,(콤마)를 구분자로 이용하여 배열로 옮기기
    var arr3 = arr1Str.split(",");
    for (let i = 0; i < arr3.length; i++) {
        console.log(arr3[i]);
    }

    // ==========================================================object==========================================================
    // ========================================================================================================================
    // 객체는 객체 리터럴을 사용하거나 / new 연산자를 통해서 생성
    // 객체 리터럴
    var obj = {
        x : "x 속성값",
        y : "y(문자열) 속성값",
        z : function () {
            return "속성 지정 함수";
        }
    }
    console.log(obj);
    console.log(obj.x);
    console.log(obj["y"]);
    console.log(obj.z);
    console.log(obj.z());
    // 접근하려는 속성이 존재하지 않을 경우 undefined를 리턴
    // 이때 || 연산자를 사용해서 undefined 대신 기본값이 반환되게 지정할 수 있다.
    // var v = obj.nonExist || “기본값”;
    console.log(obj.l || "없다");
    console.log(obj["kk"] || "진짜 없다");

    console.log("=======================================================");
    // new 연산자
    var obj2 = new Object();
    obj2.x = "가위";
    obj2["y"] = "바위";
    obj2.z = function () {
        return "hagi silta";
    }
    console.log(obj2);
    console.log(obj2.x);
    console.log(obj2['y']);
    console.log(obj2['z']);
    console.log(obj2['z']());

    // 속성값 갱신, 추가, 삭제 가능
    // 속성값 갱신
    obj2.x = "가위가위"
    console.log(obj2.x);

    // 속성값 추가
    obj2.k = "새롭게 추가";
    console.log(obj2['k']);

    // 새로운 속성에 '객체'를 추가
    // 추가될 속성의 값으로써 '다른 객체를 전달하는 것이 가능'하다.
    obj2['m'] = {new : '왜 이런걸 하지'};
    console.log(obj2.m);
    console.log(obj2);

    // 속성값 삭제 --> Delete 연산자를 사용해 특정 속성 삭제
    delete obj2.k;
    console.log(obj2);

    console.log("=======================================================");
    // 객체는 참조방식으로 전달되므로 복사되지 않는다. --> 얕은 복사
        var dog1 = {
            name: '예삐',
            breed: '푸들',
            bark: function () {
                return '왈왈';
            }
        }
        var dog2 = dog1;
        // dog1을 dog2에 할당
        // 이때 참조값이 전달되는 것이지 '새로운 객체가 생성되는 것이 아니다.'
        console.log(dog1);
        console.log(dog2);
        dog1.name = '배추도사';
        console.log(dog1.name);
        console.log(dog2.name);

        //객체참조 테스트
        var a = {}, b = {}, c = {};  //a, b, c는 각각 다른 빈 객체 참조.

        A = b = c = {}; //a, b, c는 모두 같은 빈 객체 참조.
        

    </script>
</head>
<body>
    length          배열의 크기 확인

    concat()        배열에 다른 배열이나 값을 연결하여 새로운 배열을 반환

    indexOf()       배열 요소의 인덱스 값을 반환, 해당 요소가 없을 경우 -1 반환

    join()          지정된 구분 문자열로 배열 요소들을 이어 붙여 새로운 배열 반환

    pop()           마지막 배열 요소를 반환

    push()          새로운 배열 요소를 마지막 위치에 추가

    reverse()       배열 요소의 순서를 반대로 바꿈

    slice()         배열의 일부분을 반환

    sort()          배열을 내림차순 또는 오름차순으로 정렬

    splice()        배열 요소를 추가, 삭제, 교체
</body>
</html>